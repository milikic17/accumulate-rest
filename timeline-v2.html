<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Driver Timeline v2</title>
  
  <!-- React Dependencies (CDN) -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <style>
    /*===========================================
      RESET & BASE STYLES
    ===========================================*/
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
      background: rgb(24, 30, 35);
      color: #eee;
      min-height: 100vh;
      padding: 40px;
    }

    /*===========================================
      LAYOUT: Timeline Container
      - Uses column-reverse so Day 1 appears at bottom
    ===========================================*/
    .timeline-container {
      display: flex;
      flex-direction: column-reverse;
      gap: 12px;
    }

    /*===========================================
      LAYOUT: Header Row (Add button + Time axis)
    ===========================================*/
    .header-row {
      display: flex;
      align-items: center;
      margin-bottom: 12px;
      gap: 20px;
    }

    .apply-btn {
      width: 80px;
      padding: 0;
      background: transparent;
      border: none;
      color: #2ecc71;
      font-family: inherit;
      font-size: 0.85rem;
      cursor: pointer;
      text-align: left;
      transition: color 0.15s ease;
    }

    .apply-btn:hover {
      color: #27ae60;
    }

    /*===========================================
      LAYOUT: Time Axis (Hour labels M-N-M)
    ===========================================*/
    .time-axis {
      position: relative;
      flex: 1;
      height: 20px;
    }

    .time-label {
      position: absolute;
      top: 4px;
      font-size: 0.7rem;
      color: #5a6a7a;
      transform: translateX(-50%);
    }

    .time-label:first-child {
      transform: translateX(0);
    }

    .time-label:last-child {
      transform: translateX(-100%);
    }

    /*===========================================
      LAYOUT: Day Row (Label + Track)
    ===========================================*/
    .day-row {
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .day-label {
      width: 80px;
      font-size: 0.85rem;
      color: #5a6a7a;
      flex-shrink: 0;
    }

    /*===========================================
      COMPONENT: Timeline Track
      - The horizontal line where blocks sit
    ===========================================*/
    .timeline-track {
      flex: 1;
      height: 36px;
      position: relative;
      overflow: visible;
    }

    /* The thin line running through the middle */
    .timeline-track::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 0;
      right: 0;
      height: 2px;
      background: #3a3a5a;
      transform: translateY(-50%);
      border-radius: 1px;
    }

    /*===========================================
      COMPONENT: Status Block (driving, on_duty, rest_segment)
      - Draggable rectangles representing driver statuses
    ===========================================*/
    .status-block {
      position: absolute;
      top: 4px;
      height: 28px;
      border-radius: 3px;
      cursor: grab;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.9);
      letter-spacing: 0.05em;
      user-select: none;
      z-index: 1;
      transition: box-shadow 0.15s ease;
    }

    .status-block:hover {
      box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.3);
    }

    .status-block.dragging {
      cursor: grabbing;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      z-index: 100;
    }

    /* Status type colors */
    .status-block.driving {
      background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
    }

    .status-block.on_duty {
      background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
    }

    .status-block.rest_segment {
      background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
      cursor: pointer; /* rest_segment blocks are clickable to delete */
    }

    /* Pinned statuses - cannot be moved */
    .status-block.pinned {
      border: 2px solid #e74c3c;
      cursor: not-allowed;
    }

    .status-block.pinned::after {
      content: 'ðŸ“Œ';
      position: absolute;
      top: -8px;
      right: -8px;
      font-size: 12px;
    }

    .status-block.sleeper {
      background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
    }

    /*===========================================
      COMPONENT: Gap Block (empty spaces)
      - Clickable areas between statuses
      - Click to create rest_segment block
    ===========================================*/
    .gap-block {
      position: absolute;
      top: 4px;
      height: 28px;
      border-radius: 3px;
      border: 2px dashed transparent;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      font-weight: 500;
      color: rgba(90, 106, 122, 0.6);
      z-index: 0;
      transition: border-color 0.15s ease, background 0.15s ease, color 0.15s ease;
    }

    .gap-block span {
      background: #1a1a2e;
      padding: 0 4px;
      border-radius: 2px;
    }

    /* Gap hover */
    .gap-block:hover,
    .gap-block.hovered,
    .gap-block.multi-day:hover,
    .gap-block.multi-day.hovered {
      border-color: #7f8c8d;
      color: rgba(127, 140, 141, 0.9);
      background: rgba(127, 140, 141, 0.2);
    }

    .gap-block:hover span,
    .gap-block.hovered span {
      background: transparent;
    }

    /*===========================================
      COMPONENT: Move Dialog
      - Modal for moving a status by specific amount
    ===========================================*/
    .dialog-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .move-dialog {
      background: #252540;
      border-radius: 8px;
      padding: 24px;
      min-width: 280px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }

    .dialog-title {
      font-size: 1rem;
      color: #eee;
      margin-bottom: 20px;
      text-align: center;
    }

    .dialog-row {
      margin-bottom: 16px;
    }

    .dialog-label {
      display: block;
      font-size: 0.75rem;
      color: #7f8c9a;
      margin-bottom: 8px;
    }

    /* Direction toggle */
    .direction-toggle {
      display: flex;
      gap: 8px;
    }

    .direction-btn {
      flex: 1;
      padding: 10px;
      background: #1a1a2e;
      border: 2px solid #3a3a5a;
      border-radius: 4px;
      color: #7f8c9a;
      font-family: inherit;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .direction-btn:hover {
      border-color: #5a6a7a;
    }

    .direction-btn.active {
      border-color: #2ecc71;
      color: #2ecc71;
      background: rgba(46, 204, 113, 0.1);
    }

    /* Duration inputs */
    .duration-inputs {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .duration-input {
      width: 50px;
      height: 36px;
      padding: 0;
      background: #1a1a2e;
      border: 2px solid #3a3a5a;
      border-radius: 4px;
      color: #eee;
      font-family: inherit;
      font-size: 1rem;
      text-align: center;
      /* Remove native spinner arrows */
      -moz-appearance: textfield;
    }

    .duration-input::-webkit-outer-spin-button,
    .duration-input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    .duration-input:focus {
      outline: none;
      border-color: #2ecc71;
    }

    .duration-separator {
      color: #5a6a7a;
      font-size: 1.2rem;
    }

    .duration-label {
      color: #5a6a7a;
      font-size: 0.7rem;
      text-align: center;
    }

    .duration-field {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .duration-stepper {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .stepper-btn {
      width: 36px;
      height: 36px;
      padding: 0;
      background: #1a1a2e;
      border: 1px solid #3a3a5a;
      border-radius: 4px;
      color: #7f8c9a;
      font-size: 1.2rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
    }

    .stepper-btn:hover {
      border-color: #2ecc71;
      color: #2ecc71;
    }

    .stepper-btn:active {
      background: rgba(46, 204, 113, 0.1);
    }

    /* Dialog buttons */
    .dialog-buttons {
      display: flex;
      gap: 12px;
      margin-top: 24px;
    }

    .dialog-btn {
      flex: 1;
      padding: 10px 16px;
      border-radius: 4px;
      font-family: inherit;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .dialog-btn.cancel {
      background: transparent;
      border: 1px solid #5a6a7a;
      color: #7f8c9a;
    }

    .dialog-btn.cancel:hover {
      border-color: #7f8c9a;
      color: #eee;
    }

    .dialog-btn.confirm {
      background: #2ecc71;
      border: none;
      color: #fff;
    }

    .dialog-btn.confirm:hover {
      background: #27ae60;
    }

    .dialog-btn.submit {
      background: #3498db;
      border: none;
      color: #fff;
    }

    .dialog-btn.submit:hover {
      background: #2980b9;
    }

    /* Output Modal */
    .output-modal {
      background: #252540;
      border-radius: 8px;
      padding: 24px;
      min-width: 650px;
      max-width: 900px;
      max-height: 80vh;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }

    .output-modal pre {
      background: rgb(24, 30, 35);
      padding: 16px;
      border-radius: 4px;
      overflow: auto;
      max-height: 400px;
      font-size: 0.85rem;
      color: #a0d0a0;
    }

    .output-modal .dialog-buttons {
      margin-top: 16px;
    }

    /* Output tabs */
    .output-tabs {
      display: flex;
      gap: 0;
      margin-bottom: 16px;
      border-bottom: 1px solid #3a3a5a;
    }

    .output-tab {
      padding: 8px 16px;
      background: transparent;
      border: none;
      border-bottom: 2px solid transparent;
      color: #7f8c9a;
      font-family: inherit;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .output-tab:hover {
      color: #eee;
    }

    .output-tab.active {
      color: #2ecc71;
      border-bottom-color: #2ecc71;
    }

    .output-human {
      background: rgb(24, 30, 35);
      padding: 16px;
      border-radius: 4px;
      max-height: 400px;
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.8;
      white-space: pre-wrap;
    }

    /* Comparison view */
    .compare-container {
      display: flex;
      gap: 16px;
      max-height: 400px;
    }

    .compare-side {
      flex: 1;
      min-width: 0;
      background: rgb(24, 30, 35);
      border-radius: 4px;
      padding: 12px;
      overflow: auto;
    }

    .compare-title {
      font-size: 0.7rem;
      color: #7f8c9a;
      text-transform: uppercase;
      letter-spacing: 0.03em;
      margin-bottom: 8px;
      padding-bottom: 8px;
      border-bottom: 1px solid #3a3a5a;
      white-space: nowrap;
    }

    .compare-event {
      font-size: 0.8rem;
      padding: 4px 0;
      border-bottom: 1px solid rgba(58, 58, 90, 0.5);
    }

    .compare-event:last-child {
      border-bottom: none;
    }

    .compare-event .code {
      color: #2ecc71;
      font-weight: 500;
    }

    .compare-event .code.on_duty {
      color: #3498db;
    }

    .compare-event .code.off_duty {
      color: #9b59b6;
    }

    .compare-event .code.rest_segment {
      color: #95a5a6;
    }

    .compare-event .time {
      color: #eee;
    }

    .compare-event .id {
      color: #5a6a7a;
      font-size: 0.7rem;
    }

    .compare-match {
      color: #2ecc71;
      text-align: center;
      padding: 12px;
      font-size: 0.9rem;
    }

    .compare-mismatch {
      color: #e74c3c;
      text-align: center;
      padding: 12px;
      font-size: 0.9rem;
    }

    /* Notification toast */
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #252540;
      border: 1px solid #f39c12;
      border-radius: 6px;
      padding: 12px 20px;
      color: #f39c12;
      font-size: 0.85rem;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      z-index: 2000;
      animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    /* Loading and Error states */
    .loading-container, .error-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 200px;
      color: #7f8c9a;
      font-size: 1rem;
    }

    .loader {
      width: 40px;
      height: 40px;
      border: 3px solid #3a3a5a;
      border-top-color: #2ecc71;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 16px;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .error-container {
      color: #e74c3c;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useRef, useCallback, useEffect } = React;

    /*=====================================================
      CONSTANTS
    =====================================================*/
    const MINUTES_PER_DAY = 1440; // 24 hours * 60 minutes

    /*=====================================================
      SAMPLE DATA
      - Each status has: id, code, startMinute, duration
      - startMinute is absolute (minutes from Day 1 midnight)
    =====================================================*/
    const INITIAL_STATUSES = [
      // Day 1
      { id: '1', code: 'driving', startMinute: 420, duration: 150 },
      { id: '2', code: 'on_duty', startMinute: 570, duration: 45 },
      { id: '3', code: 'driving', startMinute: 780, duration: 120 },
      { id: '4', code: 'driving', startMinute: 1080, duration: 90 },
      // Day 2
      { id: '5', code: 'on_duty', startMinute: 1560, duration: 60 },
      { id: '6', code: 'driving', startMinute: 1920, duration: 180 },
      { id: '7', code: 'driving', startMinute: 2280, duration: 120 },
      { id: '8', code: 'on_duty', startMinute: 2580, duration: 90 },
      // Day 3
      { id: '9', code: 'driving', startMinute: 3000, duration: 240 },
      { id: '10', code: 'on_duty', startMinute: 3360, duration: 60 },
      { id: '11', code: 'driving', startMinute: 3600, duration: 90 },
      { id: '12', code: 'driving', startMinute: 4020, duration: 150 },
      // Day 4
      { id: '13', code: 'driving', startMinute: 4620, duration: 180 },
      { id: '14', code: 'on_duty', startMinute: 5040, duration: 120 },
      { id: '15', code: 'driving', startMinute: 5340, duration: 60 },
    ];

    // Auto-incrementing ID for new statuses
    let nextStatusId = 100;

    /*=====================================================
      UTILITY FUNCTIONS
    =====================================================*/
    
    /**
     * Format minutes as "H:MM" duration string
     */
    function formatDuration(minutes) {
      const hours = Math.floor(minutes / 60);
      const mins = minutes % 60;
      return `${hours}:${mins.toString().padStart(2, '0')}`;
    }

    /**
     * Format date as "Dec 15" style (Central Time)
     */
    function formatDateLabel(date) {
      return date.toLocaleString('en-US', {
        timeZone: 'America/Chicago',
        month: 'short',
        day: 'numeric'
      });
    }

    /**
     * Get hour label for time axis (M for midnight, N for noon, 1-11 otherwise)
     */
    function getHourLabel(hour) {
      if (hour === 0 || hour === 24) return 'M';
      if (hour === 12) return 'N';
      return hour > 12 ? hour - 12 : hour;
    }

    /*=====================================================
      MAIN APP COMPONENT
    =====================================================*/
    function App() {
      // State
      const [numDays, setNumDays] = useState(5);
      const [statuses, setStatuses] = useState([]);
      const [dragState, setDragState] = useState(null);
      const [wasDragged, setWasDragged] = useState(false);
      const [hoveredGapId, setHoveredGapId] = useState(null);
      const [moveDialog, setMoveDialog] = useState(null); // { statusId, direction: 'left'|'right', hours: 0, minutes: 0 }
      const [periodStart, setPeriodStart] = useState(0); // Left edge - nothing can go before this
      const [periodEnd, setPeriodEnd] = useState(null);   // Right edge - nothing can go after this (null = unlimited)
      const [startDate, setStartDate] = useState(null);   // Actual date of Day 0 (for display)
      const [outputModal, setOutputModal] = useState(null); // Generated output JSON
      const [outputTab, setOutputTab] = useState('human'); // 'human' or 'json'
      const [notification, setNotification] = useState(null); // Notification message
      const [originalStatuses, setOriginalStatuses] = useState([]); // Original state for comparison at output
      const [isLoading, setIsLoading] = useState(true); // Loading state
      const [loadError, setLoadError] = useState(null); // Error message if loading fails
      
      // Refs for track elements (needed for drag calculations)
      const trackRefs = useRef({});

      /*-------------------------------------------------
        FETCH DATA FROM BACKEND
        If URL path matches /api/web/hos-event, fetch real data
      -------------------------------------------------*/
      useEffect(() => {
        const path = window.location.pathname;
        const search = window.location.search;
        
        if (!path.startsWith('/api/web/hos-event')) {
          setLoadError('Invalid URL path. Expected /api/web/hos-event/...');
          setIsLoading(false);
          return;
        }
        
        const backendUrl = `https://nestjs.eldsupport.tech${path}${search}`;
        console.log('Fetching from:', backendUrl);
        
        fetch(backendUrl, {
          method: 'GET',
          headers: {
            'Accept': 'application/json, text/plain, */*',
            'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY0ZWNkYTVmYTIwODZjZTVkOGE3NWY4MCIsImlhdCI6MTc2NTI3NzYzNX0.FlTk_ndQUPG4w-5XiNd_GIV_EG4182vdlPcALiMnFQc',
            'Origin': 'https://v2.eldsupport.tech',
            'Referer': 'https://v2.eldsupport.tech/'
          }
        })
          .then(res => {
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            return res.json();
          })
          .then(data => {
              console.log('Backend response:', data);
              
              // Response format: { data: [events] }
              const events = data.data || [];
              console.log('Events array:', events);
              
              // Filter only "Change of Duty Status" events
              const dutyStatusEvents = events.filter(event => event.eventType === 'Change of Duty Status');
              console.log('Filtered duty status events:', dutyStatusEvents);
              
              if (dutyStatusEvents.length === 0) {
                console.log('No duty status events found');
                setLoadError('No duty status events found in response');
                setIsLoading(false);
                return;
              }
              
              // Sort by eventTime to find the first event
              const sorted = [...dutyStatusEvents].sort((a, b) => 
                new Date(a.eventTime).getTime() - new Date(b.eventTime).getTime()
              );
              
              // Get the start of the first event's day (midnight)
              const firstEventTime = new Date(sorted[0].eventTime);
              const dayStart = new Date(firstEventTime);
              dayStart.setHours(0, 0, 0, 0);
              
              console.log('First event time:', firstEventTime);
              console.log('Day start (midnight):', dayStart);
              
              // Map events to our format
              const mappedStatuses = sorted.map((event, index) => {
                const eventStart = new Date(event.eventTime);
                const eventEnd = event.endEventTime ? new Date(event.endEventTime) : new Date();
                
                // Calculate startMinute relative to dayStart
                const startMinute = Math.floor((eventStart.getTime() - dayStart.getTime()) / (1000 * 60));
                
                // Calculate duration in minutes
                const duration = Math.floor((eventEnd.getTime() - eventStart.getTime()) / (1000 * 60));
                
                // Map sleeper and off_duty to rest_segment
                const isRestSegment = event.eventCode === 'sleeper' || event.eventCode === 'off_duty';
                const code = isRestSegment ? 'rest_segment' : event.eventCode;
                
                // Find the preceding non-rest status for afterId
                let afterId = null;
                for (let i = index - 1; i >= 0; i--) {
                  const prevEvent = sorted[i];
                  if (prevEvent.eventCode !== 'sleeper' && prevEvent.eventCode !== 'off_duty') {
                    afterId = prevEvent._id;
                    break;
                  }
                }
                
                // Find the following non-rest status for beforeId
                let beforeId = null;
                for (let i = index + 1; i < sorted.length; i++) {
                  const nextEvent = sorted[i];
                  if (nextEvent.eventCode !== 'sleeper' && nextEvent.eventCode !== 'off_duty') {
                    beforeId = nextEvent._id;
                    break;
                  }
                }
                
                const baseStatus = {
                  id: event._id,
                  code,
                  startMinute,
                  duration,
                  originalStartMinute: startMinute // Track original position for move detection
                };
                
                // Add tracking fields for rest segments
                if (isRestSegment) {
                  return {
                    ...baseStatus,
                    afterId,
                    beforeId, // The activity that comes AFTER this rest segment
                    originalEvents: [{
                      id: event._id,
                      code: event.eventCode,
                      duration: duration,
                      originalStartMinute: startMinute // Track original start for each event
                    }],
                    originalDuration: duration,
                    durationDelta: 0
                  };
                }
                
                return baseStatus;
              });
              
              console.log('Mapped statuses (before merge):', mappedStatuses);
              
              // Merge adjacent rest_segment blocks, then trim excess rest
              const mergedStatuses = mergeAdjacentRestSegments(mappedStatuses);
              const trimmedStatuses = trimExcessRest(mergedStatuses);
              
              console.log('Merged statuses:', mergedStatuses);
              console.log('After trimming:', trimmedStatuses);
              
              // Log which rest segments were trimmed
              console.log('=== TRIMMED REST SEGMENTS ===');
              const trimmedInfo = [];
              for (const merged of mergedStatuses) {
                if (merged.code !== 'rest_segment') continue;
                const trimmed = trimmedStatuses.find(t => t.id === merged.id);
                if (!trimmed) {
                  trimmedInfo.push({
                    restId: merged.id,
                    afterId: merged.afterId,
                    status: 'REMOVED_ENTIRELY',
                    originalDuration: merged.duration,
                    gapCreated: merged.duration
                  });
                } else if (trimmed.duration !== merged.duration) {
                  const gapCreated = merged.duration - trimmed.duration;
                  trimmedInfo.push({
                    restId: merged.id,
                    afterId: merged.afterId,
                    status: 'TRIMMED',
                    originalDuration: merged.duration,
                    trimmedTo: trimmed.duration,
                    gapCreated: gapCreated,
                    hint: `Drag activity AFTER this rest LEFT by ${gapCreated} min to trigger deletion`
                  });
                }
              }
              if (trimmedInfo.length > 0) {
                console.log(JSON.stringify(trimmedInfo, null, 2));
              } else {
                console.log('No rest segments were trimmed (all under 10h)');
              }
              console.log('=== END TRIMMED REST SEGMENTS ===');
              
              console.table(trimmedStatuses);
              
              // Calculate period boundaries from original mapped data (before trimming)
              const sortedForBounds = [...mappedStatuses].sort((a, b) => a.startMinute - b.startMinute);
              const firstEvent = sortedForBounds[0];
              const lastEvent = sortedForBounds[sortedForBounds.length - 1];
              const calcPeriodStart = firstEvent.startMinute;
              const calcPeriodEnd = lastEvent.startMinute + lastEvent.duration;
              
              console.log('Period boundaries:', { periodStart: calcPeriodStart, periodEnd: calcPeriodEnd });
              
              // Calculate how many days we need
              const daysNeeded = Math.ceil(calcPeriodEnd / MINUTES_PER_DAY);
              
              // Update state with real data
              setNumDays(Math.max(daysNeeded, 1));
              setPeriodStart(calcPeriodStart);
              setPeriodEnd(calcPeriodEnd);
              setStartDate(dayStart); // Store the actual date of Day 0
              setStatuses(trimmedStatuses);
              // Save MERGED statuses (before trim) so we keep track of rest segments that were removed entirely
              setOriginalStatuses(mergedStatuses);
              setIsLoading(false);
            })
            .catch(err => {
              console.error('Fetch error:', err);
              setLoadError(`Failed to load: ${err.message}`);
              setIsLoading(false);
            });
      }, []);

      /*-------------------------------------------------
        GAP CALCULATIONS
        Gaps are the empty spaces between statuses
      -------------------------------------------------*/
      
      /**
       * Calculate all gaps across the entire timeline
       * Returns array of { id, startMinute, duration }
       */
      const getAllGaps = useCallback(() => {
        const totalMinutes = numDays * MINUTES_PER_DAY;
        const sorted = [...statuses].sort((a, b) => a.startMinute - b.startMinute);
        
        const gaps = [];
        let currentEnd = 0;
        
        for (const status of sorted) {
          if (status.startMinute > currentEnd) {
            gaps.push({
              id: `gap-${gaps.length}`,
              startMinute: currentEnd,
              duration: status.startMinute - currentEnd
            });
          }
          currentEnd = Math.max(currentEnd, status.startMinute + status.duration);
        }
        
        // Add final gap if timeline extends past last status
        if (currentEnd < totalMinutes) {
          gaps.push({
            id: `gap-${gaps.length}`,
            startMinute: currentEnd,
            duration: totalMinutes - currentEnd
          });
        }
        
        return gaps;
      }, [statuses, numDays]);

      /**
       * Get gaps visible on a specific day
       * Each gap includes both full info and visible portion info
       */
      const getGapsForDay = useCallback((day) => {
        const dayStart = day * MINUTES_PER_DAY;
        const dayEnd = (day + 1) * MINUTES_PER_DAY;
        
        return getAllGaps()
          .filter(gap => {
            const gapEnd = gap.startMinute + gap.duration;
            return gap.startMinute < dayEnd && gapEnd > dayStart;
          })
          .map(gap => {
            const gapEnd = gap.startMinute + gap.duration;
            const visibleStart = Math.max(gap.startMinute, dayStart);
            const visibleEnd = Math.min(gapEnd, dayEnd);
            
            return {
              ...gap,
              visibleStart,
              visibleEnd,
              visibleDuration: visibleEnd - visibleStart
            };
          });
      }, [getAllGaps]);

      /**
       * Get statuses visible on a specific day
       * Each status includes visibility info for proper rendering
       */
      const getStatusesForDay = useCallback((day) => {
        const dayStart = day * MINUTES_PER_DAY;
        const dayEnd = (day + 1) * MINUTES_PER_DAY;
        
        // Sort all statuses to find adjacent gaps
        const sorted = [...statuses].sort((a, b) => a.startMinute - b.startMinute);
        
        // Pre-calculate gaps for each status
        const statusGaps = {};
        for (let i = 0; i < sorted.length; i++) {
          const status = sorted[i];
          let gapBefore = 0;
          let gapAfter = 0;
          
          // Gap before (from previous status end to this status start)
          if (i > 0) {
            const prev = sorted[i - 1];
            const prevEnd = prev.startMinute + prev.duration;
            if (status.startMinute > prevEnd) {
              gapBefore = status.startMinute - prevEnd;
            }
          }
          
          // Gap after (from this status end to next status start)
          if (i < sorted.length - 1) {
            const next = sorted[i + 1];
            const thisEnd = status.startMinute + status.duration;
            if (next.startMinute > thisEnd) {
              gapAfter = next.startMinute - thisEnd;
            }
          }
          
          statusGaps[status.id] = { gapBefore, gapAfter };
        }
        
        return statuses
          .filter(status => {
            const statusEnd = status.startMinute + status.duration;
            return status.startMinute < dayEnd && statusEnd > dayStart;
          })
          .map(status => {
            const statusEnd = status.startMinute + status.duration;
            const visibleStart = Math.max(status.startMinute, dayStart);
            const visibleEnd = Math.min(statusEnd, dayEnd);
            const gaps = statusGaps[status.id] || { gapBefore: 0, gapAfter: 0 };
            
            return {
              ...status,
              visibleStart,
              visibleEnd,
              visibleDuration: visibleEnd - visibleStart,
              clippedLeft: status.startMinute < dayStart,
              clippedRight: statusEnd > dayEnd,
              gapBefore: gaps.gapBefore,
              gapAfter: gaps.gapAfter
            };
          });
      }, [statuses]);

      /*-------------------------------------------------
        STATUS MANAGEMENT
      -------------------------------------------------*/
      
      /**
       * Merge adjacent rest_segment blocks into one
       * Called after creating or dragging blocks
       */
      const mergeAdjacentRestSegments = useCallback((statusList) => {
        const sorted = [...statusList].sort((a, b) => a.startMinute - b.startMinute);
        const merged = [];
        
        for (const status of sorted) {
          const last = merged[merged.length - 1];
          
          // Merge if both are rest_segment and adjacent
          if (last?.code === 'rest_segment' && 
              status.code === 'rest_segment' &&
              last.startMinute + last.duration === status.startMinute) {
            // Combine durations
            last.duration += status.duration;
            // Combine originalEvents
            if (status.originalEvents) {
              last.originalEvents = [...(last.originalEvents || []), ...status.originalEvents];
            }
            // Sum originalDuration
            if (status.originalDuration !== undefined) {
              last.originalDuration = (last.originalDuration || 0) + status.originalDuration;
            }
            // Keep afterId from first segment (already set)
            // Take beforeId from last segment being merged (it points to activity after the rest)
            if (status.beforeId) {
              last.beforeId = status.beforeId;
            }
          } else {
            merged.push({ ...status });
          }
        }
        
        return merged;
      }, []);

      /**
       * Trim excess rest from rest_segment blocks
       * Rules:
       * - < 30 min: entirely excess (removed, becomes gap)
       * - 30 min to 10h: necessary (kept as is)
       * - 10h to 34h: trim to 10h (shift reset)
       * - > 34h: trim to 34h (cycle reset)
       */
      const trimExcessRest = useCallback((statusList) => {
        const MIN_BREAK = 30;       // 30 minutes minimum for break reset
        const SHIFT_RESET = 601;    // 10 hours 1 min (601 min) for shift reset
        const CYCLE_RESET = 2041;   // 34 hours 1 min (2041 min) for cycle reset
        
        return statusList
          .map(status => {
            if (status.code !== 'rest_segment') {
              return status; // Keep non-rest_segment as is
            }
            
            // < 30 min: remove entirely
            if (status.duration < MIN_BREAK) {
              return null;
            }
            
            let newDuration = status.duration;
            
            // >= 34h: trim to 34h (cycle reset)
            if (status.duration >= CYCLE_RESET) {
              newDuration = CYCLE_RESET;
            }
            // > 10h but < 34h: trim to 10h (shift reset)
            else if (status.duration > SHIFT_RESET && status.duration < CYCLE_RESET) {
              newDuration = SHIFT_RESET;
            }
            
            return {
              ...status,
              duration: newDuration
            };
          })
          .filter(Boolean); // Remove nulls
      }, []);

      /**
       * Create rest_segment block in a gap (called when gap is clicked)
       */
      const handleGapClick = useCallback((gap) => {
        setHoveredGapId(null); // Clear hover to prevent stale highlights
        
        // Clamp gap to period boundaries
        const effectivePeriodEnd = periodEnd !== null ? periodEnd : (numDays * MINUTES_PER_DAY);
        const clampedStart = Math.max(gap.startMinute, periodStart);
        const clampedEnd = Math.min(gap.startMinute + gap.duration, effectivePeriodEnd);
        const clampedDuration = clampedEnd - clampedStart;
        
        // Don't create if gap is entirely outside bounds
        if (clampedDuration <= 0) {
          console.log('Gap is outside period boundaries, not creating rest segment');
          return;
        }
        
        // Find the status that comes before this gap
        const sorted = [...statuses].sort((a, b) => a.startMinute - b.startMinute);
        let afterId = null;
        for (const s of sorted) {
          if (s.startMinute + s.duration <= clampedStart && s.code !== 'rest_segment') {
            afterId = s.id;
          }
        }
        
        const newStatus = {
          id: String(nextStatusId++),
          code: 'rest_segment',
          startMinute: clampedStart,
          duration: clampedDuration,
          afterId,
          originalEvents: [], // User-created, no backend events
          originalDuration: clampedDuration,
          durationDelta: 0
        };
        
        // Only merge, don't trim - trimming happens after moves
        setStatuses(prev => mergeAdjacentRestSegments([...prev, newStatus]));
      }, [statuses, mergeAdjacentRestSegments, periodStart, periodEnd, numDays]);

      /**
       * Remove rest_segment block (called when rest_segment is clicked)
       */
      const handleRestSegmentClick = useCallback((statusId) => {
        setStatuses(prev => prev.filter(s => s.id !== statusId));
      }, []);

      /**
       * Open move dialog for a status (driving/on_duty only)
       */
      const handleStatusClick = useCallback((statusId) => {
        setMoveDialog({
          statusId,
          direction: 'left',
          hours: 0,
          minutes: 0
        });
      }, []);

      /**
       * Calculate max possible movement for a status in a given direction
       */
      const calculateMaxMove = useCallback((statusId, direction) => {
        const sorted = [...statuses].sort((a, b) => a.startMinute - b.startMinute);
        const statusIdx = sorted.findIndex(s => s.id === statusId);
        const status = sorted[statusIdx];
        
        if (!status) return 0;
        
        const effectivePeriodEnd = periodEnd !== null ? periodEnd : (numDays * MINUTES_PER_DAY);
        
        if (direction === 'left') {
          // Max left = distance to period start (considering all blocks that would be pushed)
          // Find total duration of all blocks from start to this one
          let totalDuration = 0;
          for (let i = 0; i <= statusIdx; i++) {
            totalDuration += sorted[i].duration;
            // Check for pinned blocks - they limit movement
            if (i < statusIdx && sorted[i].pinned) {
              // Can only move as far as the gap after this pinned block
              const pinnedEnd = sorted[i].startMinute + sorted[i].duration;
              return status.startMinute - pinnedEnd;
            }
          }
          // Max movement is current position minus where we'd end up at periodStart
          return status.startMinute - (periodStart + totalDuration - status.duration);
        } else {
          // Max right = distance to period end (considering all blocks that would be pushed)
          let totalDuration = 0;
          for (let i = statusIdx; i < sorted.length; i++) {
            totalDuration += sorted[i].duration;
            // Check for pinned blocks - they limit movement
            if (i > statusIdx && sorted[i].pinned) {
              // Can only move as far as the gap before this pinned block
              return sorted[i].startMinute - (status.startMinute + status.duration);
            }
          }
          // Max movement is where we'd end up at periodEnd minus current position
          return (effectivePeriodEnd - totalDuration) - status.startMinute;
        }
      }, [statuses, periodStart, periodEnd, numDays]);

      /**
       * Apply the move from the dialog
       * Uses same collision logic as dragging
       */
      const applyMove = useCallback(() => {
        if (!moveDialog) return;
        
        const { statusId, direction, hours, minutes } = moveDialog;
        const moveMinutes = (hours * 60) + minutes;
        
        if (moveMinutes === 0) {
          setMoveDialog(null);
          return;
        }
        
        // Check if move exceeds max possible - cap at max and notify
        const maxMove = calculateMaxMove(statusId, direction);
        let actualMoveMinutes = moveMinutes;
        
        if (moveMinutes > maxMove) {
          actualMoveMinutes = Math.max(0, maxMove);
          const maxHours = Math.floor(maxMove / 60);
          const maxMins = Math.round(maxMove % 60);
          setNotification(`Movement capped at ${maxHours}h ${maxMins}m (maximum ${direction})`);
          // Auto-dismiss after 3 seconds
          setTimeout(() => setNotification(null), 3000);
          
          if (actualMoveMinutes <= 0) {
            setMoveDialog(null);
            return;
          }
        }
        
        setStatuses(prev => {
          // Sort by current positions
          const sorted = [...prev].sort((a, b) => a.startMinute - b.startMinute);
          const draggedSortedIdx = sorted.findIndex(s => s.id === statusId);
          const dragged = sorted[draggedSortedIdx];
          
          // Calculate desired new position
          let desiredStart = direction === 'left' 
            ? dragged.startMinute - actualMoveMinutes
            : dragged.startMinute + actualMoveMinutes;
          
          // Create working copy
          const updated = sorted.map(s => ({ ...s }));
          const draggedInUpdated = updated[draggedSortedIdx];
          
          // Clamp to period bounds
          const effectivePeriodEnd = periodEnd !== null ? periodEnd : (numDays * MINUTES_PER_DAY);
          desiredStart = Math.max(periodStart, desiredStart);
          desiredStart = Math.min(desiredStart, effectivePeriodEnd - dragged.duration);
          
          if (direction === 'right') {
            // Moving right: push following blocks (stop at pinned)
            draggedInUpdated.startMinute = desiredStart;
            
            for (let i = draggedSortedIdx; i < updated.length - 1; i++) {
              const current = updated[i];
              const next = updated[i + 1];
              const currentEnd = current.startMinute + current.duration;
              
              if (currentEnd > next.startMinute) {
                if (next.pinned) {
                  // Pull back if we hit a pinned block
                  const pullback = currentEnd - next.startMinute;
                  for (let j = draggedSortedIdx; j <= i; j++) {
                    updated[j].startMinute -= pullback;
                  }
                  break;
                }
                next.startMinute = currentEnd;
              } else {
                break;
              }
            }
            
            // Handle overflow at end of period
            const lastBlock = updated[updated.length - 1];
            const lastBlockEnd = lastBlock.startMinute + lastBlock.duration;
            
            if (lastBlockEnd > effectivePeriodEnd) {
              const overflow = lastBlockEnd - effectivePeriodEnd;
              for (let i = draggedSortedIdx; i < updated.length; i++) {
                if (!updated[i].pinned) {
                  updated[i].startMinute -= overflow;
                }
              }
            }
          } else {
            // Moving left: push preceding blocks (stop at pinned)
            draggedInUpdated.startMinute = desiredStart;
            
            for (let i = draggedSortedIdx; i > 0; i--) {
              const current = updated[i];
              const prev = updated[i - 1];
              const prevEnd = prev.startMinute + prev.duration;
              
              if (prevEnd > current.startMinute) {
                if (prev.pinned) {
                  // Push back if we hit a pinned block
                  const pushback = prevEnd - current.startMinute;
                  for (let j = i; j <= draggedSortedIdx; j++) {
                    updated[j].startMinute += pushback;
                  }
                  break;
                }
                prev.startMinute -= (prevEnd - current.startMinute);
              } else {
                break;
              }
            }
            
            // Handle underflow at start of period
            const firstBlock = updated[0];
            if (firstBlock.startMinute < periodStart) {
              const underflow = periodStart - firstBlock.startMinute;
              for (let i = 0; i <= draggedSortedIdx; i++) {
                if (!updated[i].pinned) {
                  updated[i].startMinute += underflow;
                }
              }
            }
          }
          
          return trimExcessRest(mergeAdjacentRestSegments(updated));
        });
        
        setMoveDialog(null);
      }, [moveDialog, numDays, periodStart, periodEnd, mergeAdjacentRestSegments, trimExcessRest, calculateMaxMove]);

      /*-------------------------------------------------
        OUTPUT GENERATION
      -------------------------------------------------*/

      /**
       * Generate output comparing current state with original
       * Returns object with moved, deleted, and created events
       */
      const generateOutput = useCallback(() => {
        if (!startDate) {
          console.error('No start date available');
          return {};
        }

        const output = {};
        const currentSorted = [...statuses].sort((a, b) => a.startMinute - b.startMinute);
        const originalSorted = [...originalStatuses].sort((a, b) => a.startMinute - b.startMinute);
        
        // Helper to convert startMinute to timestamp
        const toTimestamp = (minute) => {
          return startDate.getTime() + (minute * 60 * 1000) + Math.floor(Math.random() * 60000);
        };

        // Step 1: Check all events (driving/on_duty/rest_segment) for moves
        for (const status of currentSorted) {
          if (status.originalStartMinute !== undefined && 
              status.startMinute !== status.originalStartMinute) {
            // Status was moved
            output[status.id] = toTimestamp(status.startMinute);
          }
        }

        // Step 2: Calculate current gaps (space between adjacent statuses)
        const currentGaps = {};
        for (let i = 0; i < currentSorted.length - 1; i++) {
          const current = currentSorted[i];
          const next = currentSorted[i + 1];
          const gapStart = current.startMinute + current.duration;
          const gapDuration = next.startMinute - gapStart;
          if (current.code === 'driving' || current.code === 'on_duty') {
            currentGaps[current.id] = { start: gapStart, duration: Math.max(0, gapDuration) };
          }
        }

        // Step 3: For each ORIGINAL rest segment, check if its events should be deleted
        // Group original rest segments by afterId
        const originalRestByAfterId = {};
        for (const status of originalSorted) {
          if (status.code === 'rest_segment' && status.afterId) {
            if (!originalRestByAfterId[status.afterId]) {
              originalRestByAfterId[status.afterId] = [];
            }
            originalRestByAfterId[status.afterId].push(status);
          }
        }

        // For each activity in original, check rest that followed it
        console.log('=== generateOutput: Checking rest deletions ===');
        const restCheckResults = [];
        
        for (const activity of originalSorted) {
          if (activity.code !== 'driving' && activity.code !== 'on_duty') continue;

          const originalRestSegments = originalRestByAfterId[activity.id] || [];
          if (originalRestSegments.length === 0) continue;

          // Get all original events from the rest segments
          let originalEvents = [];
          let originalTotalDuration = 0;
          let beforeId = null; // The activity that comes AFTER this rest segment
          for (const rs of originalRestSegments) {
            if (rs.originalEvents) {
              originalEvents = [...originalEvents, ...rs.originalEvents];
            }
            originalTotalDuration += rs.originalDuration || rs.duration;
            // Take the beforeId from the last rest segment (points to activity after rest)
            if (rs.beforeId) {
              beforeId = rs.beforeId;
            }
          }

          if (originalEvents.length === 0) continue;

          // Find the current activity (it may have moved)
          const currentActivity = currentSorted.find(s => s.id === activity.id);
          if (!currentActivity) {
            restCheckResults.push({
              activityId: activity.id,
              activityCode: activity.code,
              status: 'ACTIVITY_NOT_FOUND'
            });
            continue;
          }

          const currentActivityEnd = currentActivity.startMinute + currentActivity.duration;

          // Find the activity that was ORIGINALLY after this rest segment (by beforeId)
          // This is more reliable than searching by position since activities can overlap after dragging
          let effectiveRestDuration = 0;
          let nextActivityInfo = null;
          
          if (beforeId) {
            const nextActivity = currentSorted.find(s => s.id === beforeId);
            if (nextActivity) {
              // Calculate gap - can be negative if they overlap now
              effectiveRestDuration = Math.max(0, nextActivity.startMinute - currentActivityEnd);
              nextActivityInfo = { id: nextActivity.id, startMinute: nextActivity.startMinute };
            } else {
              // Activity not found - rest extends to end of period
              effectiveRestDuration = (periodEnd || (numDays * 1440)) - currentActivityEnd;
              nextActivityInfo = { id: 'periodEnd', startMinute: periodEnd || (numDays * 1440) };
            }
          } else {
            // No beforeId - find next activity by position (fallback)
            const nextActivityIdx = currentSorted.findIndex(
              s => (s.code === 'driving' || s.code === 'on_duty') && 
                   s.startMinute > currentActivityEnd
            );
            if (nextActivityIdx !== -1) {
              const nextActivity = currentSorted[nextActivityIdx];
              effectiveRestDuration = nextActivity.startMinute - currentActivityEnd;
              nextActivityInfo = { id: nextActivity.id, startMinute: nextActivity.startMinute };
            } else {
              // No next activity - rest extends to end of period
              effectiveRestDuration = (periodEnd || (numDays * 1440)) - currentActivityEnd;
              nextActivityInfo = { id: 'periodEnd', startMinute: periodEnd || (numDays * 1440) };
            }
          }

          const isDeletionCandidate = effectiveRestDuration < originalTotalDuration;
          
          restCheckResults.push({
            activityId: activity.id,
            activityCode: activity.code,
            currentActivityEnd,
            beforeId,
            nextActivity: nextActivityInfo,
            effectiveRestDuration,
            originalTotalDuration,
            diff: effectiveRestDuration - originalTotalDuration,
            isDeletionCandidate,
            originalEventIds: originalEvents.map(e => e.id)
          });

          // Compare: effective rest vs original rest
          // Calculate debt (how much rest was "eaten")
          const debt = originalTotalDuration - effectiveRestDuration;
          
          console.log(`Activity ${activity.id}: debt=${debt}, originalTotal=${originalTotalDuration}, effective=${effectiveRestDuration}, beforeId=${beforeId}`);
          console.log(`  Events:`, originalEvents.map(e => ({ id: e.id, duration: e.duration })));
          
          if (debt > 0) {
            // Rest shrunk - delete events from right to left until debt is paid
            let remainingDebt = debt;
            
            // Process events from right to left (reverse order)
            for (let i = originalEvents.length - 1; i >= 0 && remainingDebt > 0; i--) {
              const evt = originalEvents[i];
              
              console.log(`  Checking event ${evt.id}: duration=${evt.duration}, remainingDebt=${remainingDebt}, willDelete=${evt.duration <= remainingDebt}`);
              
              if (evt.duration <= remainingDebt) {
                // Event is fully consumed by debt - DELETE
                console.log(`  -> DELETING event ${evt.id}`);
                output[evt.id] = null;
                remainingDebt -= evt.duration;
              } else {
                // Event absorbs remaining debt but survives - KEEP
                // (its duration > debt, so it has remaining time)
                console.log(`  -> KEEPING event ${evt.id} (absorbs ${remainingDebt} min of debt)`);
                break;
              }
            }
          } else {
            console.log(`  No debt - nothing to delete`);
          }
          // If debt <= 0, rest got bigger or stayed same - nothing to delete
        }
        
        // Log the rest check results
        console.log('Rest check results:');
        console.log(JSON.stringify(restCheckResults, null, 2));
        
        const deletionCandidates = restCheckResults.filter(r => r.isDeletionCandidate);
        if (deletionCandidates.length > 0) {
          console.log('*** DELETION CANDIDATES FOUND:');
          console.log(JSON.stringify(deletionCandidates, null, 2));
        } else {
          console.log('No deletion candidates found (all effectiveRestDuration >= originalTotalDuration)');
        }

        // Step 3.5: Detect rest_segments that were removed during initial trimming
        // These are in originalStatuses but not in current statuses
        const currentIds = new Set(currentSorted.map(s => s.id));
        for (const original of originalSorted) {
          if (original.code === 'rest_segment' && !currentIds.has(original.id)) {
            // This rest_segment was removed (trimmed) - mark for deletion
            if (!(original.id in output)) {
              console.log(`Trimmed rest_segment detected: ${original.id} (duration: ${original.duration})`);
              output[original.id] = null;
            }
          }
        }

        // Step 4: Check for gaps and either move existing rest_segment or create new off_duty
        let newEventCounter = 0;
        for (let i = 0; i < currentSorted.length - 1; i++) {
          const current = currentSorted[i];
          const next = currentSorted[i + 1];
          
          const gapStart = current.startMinute + current.duration;
          const gapDuration = next.startMinute - gapStart;
          
          // If there's a gap > 0, we need to fill it
          if (gapDuration > 0) {
            // Check if there was originally a rest_segment after this event (by afterId)
            const originalRestAfterCurrent = originalSorted.find(s => 
              s.code === 'rest_segment' && s.afterId === current.id
            );
            
            if (originalRestAfterCurrent) {
              // There was a rest_segment here originally - MOVE it to fill the gap
              // (don't delete it, move it instead)
              const newTimestamp = toTimestamp(gapStart);
              output[originalRestAfterCurrent.id] = newTimestamp;
              // Remove any deletion that was added for this rest_segment
              // (it's being moved, not deleted)
            } else {
              // No original rest_segment here - check if we need a new off_duty
              const originalCurrent = originalSorted.find(s => s.id === current.id);
              const originalNext = originalSorted.find(s => s.id === next.id);
              
              let originalGapBetweenThese = 0;
              if (originalCurrent && originalNext) {
                originalGapBetweenThese = originalNext.startMinute - (originalCurrent.startMinute + originalCurrent.duration);
              }
              
              // Create off_duty if the gap is new or bigger than original
              if (gapDuration > Math.max(0, originalGapBetweenThese)) {
                output[`off_duty_${newEventCounter++}`] = toTimestamp(gapStart);
              }
            }
          }
        }

        return output;
      }, [statuses, originalStatuses, startDate]);

      /**
       * Format output as human-readable text
       */
      const formatOutputHuman = useCallback((output) => {
        if (!startDate) return 'No start date available';
        
        const lines = [];
        
        const formatTime = (timestamp) => {
          const date = new Date(timestamp);
          return date.toLocaleString('en-US', { 
            timeZone: 'America/Chicago',
            month: 'short', 
            day: 'numeric', 
            hour: 'numeric', 
            minute: '2-digit',
            hour12: true 
          });
        };
        
        const formatMinute = (minute) => {
          const date = new Date(startDate.getTime() + minute * 60 * 1000);
          return date.toLocaleString('en-US', { 
            timeZone: 'America/Chicago',
            month: 'short', 
            day: 'numeric', 
            hour: 'numeric', 
            minute: '2-digit',
            hour12: true 
          });
        };
        
        for (const [key, value] of Object.entries(output)) {
          if (key.startsWith('off_duty_')) {
            // New off_duty event (unique key like off_duty_0, off_duty_1, etc.)
            lines.push(`âž• Add off_duty at ${formatTime(value)}`);
          } else if (value === null) {
            // Deletion - find original info
            const originalStatus = originalStatuses.find(s => s.id === key);
            const code = originalStatus?.code || 'event';
            const originalTime = originalStatus?.originalStartMinute;
            const timeStr = originalTime !== undefined ? ` (was at ${formatMinute(originalTime)})` : '';
            lines.push(`ðŸ—‘ï¸ Delete ${code} ${key.slice(-6)}${timeStr}`);
          } else {
            // Moved event
            const status = statuses.find(s => s.id === key);
            const originalStatus = originalStatuses.find(s => s.id === key);
            const code = status?.code || 'event';
            const originalTime = originalStatus?.originalStartMinute;
            const fromStr = originalTime !== undefined ? formatMinute(originalTime) : 'unknown';
            lines.push(`â†”ï¸ Move ${code} ${key.slice(-6)} from ${fromStr} to ${formatTime(value)}`);
          }
        }
        
        if (lines.length === 0) {
          return 'No changes to submit';
        }
        
        return lines.join('\n');
      }, [statuses, originalStatuses, startDate]);

      /**
       * Generate comparison data: current state vs original+changes
       */
      const generateComparisonData = useCallback((output) => {
        if (!startDate) return { left: [], right: [] };
        
        const formatTimestamp = (timestamp) => {
          const date = new Date(timestamp);
          return date.toLocaleString('en-US', { 
            timeZone: 'America/Chicago',
            month: 'short', 
            day: 'numeric', 
            hour: 'numeric', 
            minute: '2-digit',
            hour12: true 
          });
        };
        
        const minuteToTimestamp = (minute) => {
          return startDate.getTime() + minute * 60 * 1000;
        };
        
        // LEFT SIDE: Current state (all events, sorted by time)
        const currentEvents = statuses
          .map(s => ({
            id: s.id,
            code: s.code,
            timestamp: minuteToTimestamp(s.startMinute),
            time: formatTimestamp(minuteToTimestamp(s.startMinute))
          }))
          .sort((a, b) => a.timestamp - b.timestamp);
        
        // RIGHT SIDE: Original state + output changes applied
        // Start with original events
        const originalEvents = originalStatuses
          .map(s => ({
            id: s.id,
            code: s.code,
            timestamp: minuteToTimestamp(s.originalStartMinute ?? s.startMinute),
            time: formatTimestamp(minuteToTimestamp(s.originalStartMinute ?? s.startMinute))
          }));
        
        // Apply output changes
        const simulatedEvents = [...originalEvents];
        
        for (const [key, value] of Object.entries(output)) {
          if (key.startsWith('off_duty_')) {
            // New event - add it (unique key like off_duty_0, off_duty_1, etc.)
            simulatedEvents.push({
              id: 'NEW',
              code: 'off_duty',
              timestamp: value,
              time: formatTimestamp(value)
            });
          } else if (value === null) {
            // Deletion - remove it
            const idx = simulatedEvents.findIndex(e => e.id === key);
            if (idx !== -1) simulatedEvents.splice(idx, 1);
          } else {
            // Move - update timestamp
            const evt = simulatedEvents.find(e => e.id === key);
            if (evt) {
              evt.timestamp = value;
              evt.time = formatTimestamp(value);
            }
          }
        }
        
        // Sort by timestamp
        simulatedEvents.sort((a, b) => a.timestamp - b.timestamp);
        
        return {
          left: currentEvents,
          right: simulatedEvents
        };
      }, [statuses, originalStatuses, startDate]);

      /**
       * Format output for the API webhook
       * Transforms { eventId: timestamp/null, "off_duty": timestamp } 
       * to { ticketId, events: [{ _id, eventCode, eventTime }] }
       */
      const formatOutputForApi = useCallback((output) => {
        const events = [];
        
        for (const [key, value] of Object.entries(output)) {
          if (key.startsWith('off_duty_')) {
            // New off_duty event (unique key like off_duty_0, off_duty_1, etc.)
            events.push({
              _id: null,
              eventCode: 'off_duty',
              eventTime: value
            });
          } else if (value === null) {
            // Deletion - eventCode is null
            events.push({
              _id: key,
              eventCode: null
            });
          } else {
            // Moved event - look up eventCode from statuses
            const status = statuses.find(s => s.id === key);
            const eventCode = status?.code || 'unknown';
            events.push({
              _id: key,
              eventCode: eventCode,
              eventTime: value
            });
          }
        }
        
        return {
          ticketId: '69446e10b6fda75604fccaff',
          events
        };
      }, [statuses]);

      /**
       * Handle Generate Output button click
       */
      const handleGenerateOutput = useCallback(() => {
        const output = generateOutput();
        console.log('Generated output:', output);
        setOutputModal(JSON.stringify(output, null, 2));
      }, [generateOutput]);

      /*-------------------------------------------------
        DRAG & DROP LOGIC
      -------------------------------------------------*/
      
      /**
       * Start dragging a status block
       */
      const handleMouseDown = useCallback((e, statusId, day) => {
        e.preventDefault();
        
        const track = trackRefs.current[day];
        if (!track) return;

        const status = statuses.find(s => s.id === statusId);
        
        // Don't allow dragging pinned statuses
        if (status?.pinned) return;
        
        setDragState({
          statusId,
          startX: e.clientX,
          originalStartMinute: status.startMinute,
          trackRect: track.getBoundingClientRect()
        });
      }, [statuses]);

      /**
       * Handle mouse movement during drag
       * - Updates dragged status position
       * - Pushes colliding statuses (cascade effect)
       * - Maintains proper ordering (blocks can't jump over each other)
       */
      const handleMouseMove = useCallback((e) => {
        if (!dragState) return;

        const { statusId, startX, originalStartMinute, trackRect } = dragState;
        const deltaX = e.clientX - startX;
        
        // Mark as dragged if moved more than 3px (to distinguish from click)
        if (Math.abs(deltaX) > 3) {
          setWasDragged(true);
        }
        
        // Convert pixel movement to minutes
        const minutesPerPixel = MINUTES_PER_DAY / trackRect.width;
        const deltaMinutes = Math.round(deltaX * minutesPerPixel);
        
        // Calculate desired new position
        let desiredStart = originalStartMinute + deltaMinutes;

        setStatuses(prev => {
          // Sort by CURRENT positions to establish order
          const sorted = [...prev].sort((a, b) => a.startMinute - b.startMinute);
          const draggedSortedIdx = sorted.findIndex(s => s.id === statusId);
          const dragged = sorted[draggedSortedIdx];
          
          // Create a working copy
          const updated = sorted.map(s => ({ ...s }));
          const draggedInUpdated = updated[draggedSortedIdx];
          
          // Clamp desired position to period bounds
          const effectivePeriodEnd = periodEnd !== null ? periodEnd : (numDays * MINUTES_PER_DAY);
          desiredStart = Math.max(periodStart, desiredStart);
          desiredStart = Math.min(desiredStart, effectivePeriodEnd - dragged.duration);
          
          const movingRight = desiredStart > dragged.startMinute;
          const movingLeft = desiredStart < dragged.startMinute;
          
          if (movingRight) {
            // MOVING RIGHT: Push blocks to the right
            draggedInUpdated.startMinute = desiredStart;
            
            // Cascade push to the right (stop at pinned blocks)
            for (let i = draggedSortedIdx; i < updated.length - 1; i++) {
              const current = updated[i];
              const next = updated[i + 1];
              const currentEnd = current.startMinute + current.duration;
              
              if (currentEnd > next.startMinute) {
                // If next block is pinned, we can't push it - pull back instead
                if (next.pinned) {
                  const pullback = currentEnd - next.startMinute;
                  // Pull back all blocks from dragged to current
                  for (let j = draggedSortedIdx; j <= i; j++) {
                    updated[j].startMinute -= pullback;
                  }
                  break;
                }
                // Push next block
                next.startMinute = currentEnd;
              } else {
                break; // No more collisions
              }
            }
            
            // Check if last block exceeds period end - if so, pull everything back
            const lastBlock = updated[updated.length - 1];
            const lastBlockEnd = lastBlock.startMinute + lastBlock.duration;
            const maxEnd = periodEnd !== null ? periodEnd : (numDays * MINUTES_PER_DAY);
            
            if (lastBlockEnd > maxEnd) {
              const overflow = lastBlockEnd - maxEnd;
              // Pull all blocks back by overflow amount
              for (let i = draggedSortedIdx; i < updated.length; i++) {
                if (!updated[i].pinned) {
                  updated[i].startMinute -= overflow;
                }
              }
            }
            
          } else if (movingLeft) {
            // MOVING LEFT: Push blocks to the left
            draggedInUpdated.startMinute = desiredStart;
            
            // Cascade push to the left (stop at pinned blocks)
            for (let i = draggedSortedIdx; i > 0; i--) {
              const current = updated[i];
              const prev = updated[i - 1];
              const prevEnd = prev.startMinute + prev.duration;
              
              if (prevEnd > current.startMinute) {
                // If prev block is pinned, we can't push it - push back instead
                if (prev.pinned) {
                  const pushback = prevEnd - current.startMinute;
                  // Push back all blocks from current to dragged
                  for (let j = i; j <= draggedSortedIdx; j++) {
                    updated[j].startMinute += pushback;
                  }
                  break;
                }
                // Push prev block left
                const pushAmount = prevEnd - current.startMinute;
                prev.startMinute -= pushAmount;
              } else {
                break; // No more collisions
              }
            }
            
            // Check if first block goes below periodStart - if so, push everything back right
            const firstBlock = updated[0];
            if (firstBlock.startMinute < periodStart) {
              const underflow = periodStart - firstBlock.startMinute;
              // Push all affected blocks right by underflow amount
              for (let i = 0; i <= draggedSortedIdx; i++) {
                if (!updated[i].pinned) {
                  updated[i].startMinute += underflow;
                }
              }
            }
          }
          
          return updated;
        });
      }, [dragState, numDays, periodStart, periodEnd]);

      /**
       * End drag operation
       */
      const handleMouseUp = useCallback(() => {
        setStatuses(prev => trimExcessRest(mergeAdjacentRestSegments(prev)));
        setDragState(null);
        setTimeout(() => setWasDragged(false), 10);
      }, [mergeAdjacentRestSegments, trimExcessRest]);

      // Attach/detach global mouse listeners during drag
      useEffect(() => {
        if (dragState) {
          window.addEventListener('mousemove', handleMouseMove);
          window.addEventListener('mouseup', handleMouseUp);
          return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
          };
        }
      }, [dragState, handleMouseMove, handleMouseUp]);

      /*-------------------------------------------------
        RENDER
      -------------------------------------------------*/
      
      // Show loading state
      if (isLoading) {
        return (
          <div className="loading-container">
            <div className="loader"></div>
            <div>Loading...</div>
          </div>
        );
      }
      
      // Show error state
      if (loadError) {
        return (
          <div className="error-container">
            <div>{loadError}</div>
          </div>
        );
      }
      
      return (
        <div>
          {/* Header: Output button + Time axis */}
          <div className="header-row">
            <button className="apply-btn" onClick={handleGenerateOutput}>
              Output
            </button>
            <TimeAxis />
          </div>
          
          {/* Timeline rows (reversed so Day 1 is at bottom) */}
          <div className="timeline-container">
            {Array.from({ length: numDays }, (_, day) => (
              <DayRow
                key={day}
                day={day}
                statuses={getStatusesForDay(day)}
                gaps={getGapsForDay(day)}
                onMouseDown={handleMouseDown}
                onGapClick={handleGapClick}
                onRestSegmentClick={handleRestSegmentClick}
                onStatusClick={handleStatusClick}
                draggingId={dragState?.statusId}
                wasDragged={wasDragged}
                hoveredGapId={hoveredGapId}
                onGapHover={setHoveredGapId}
                trackRef={el => trackRefs.current[day] = el}
                startDate={startDate}
              />
            ))}
          </div>
          
          
          {/* Move Dialog */}
          {moveDialog && (
            <MoveDialog
              dialog={moveDialog}
              onUpdate={setMoveDialog}
              onConfirm={applyMove}
              onCancel={() => setMoveDialog(null)}
            />
          )}

          {/* Notification Toast */}
          {notification && (
            <div className="notification">
              {notification}
            </div>
          )}

          {/* Output Modal */}
          {outputModal && (
            <div className="dialog-overlay" onClick={() => setOutputModal(null)}>
              <div className="output-modal" onClick={e => e.stopPropagation()}>
                <div className="dialog-title">Generated Output</div>
                
                {/* Tabs */}
                <div className="output-tabs">
                  <button 
                    className={`output-tab ${outputTab === 'human' ? 'active' : ''}`}
                    onClick={() => setOutputTab('human')}
                  >
                    Summary
                  </button>
                  <button 
                    className={`output-tab ${outputTab === 'compare' ? 'active' : ''}`}
                    onClick={() => setOutputTab('compare')}
                  >
                    Compare
                  </button>
                  <button 
                    className={`output-tab ${outputTab === 'json' ? 'active' : ''}`}
                    onClick={() => setOutputTab('json')}
                  >
                    JSON
                  </button>
                </div>
                
                {/* Tab Content */}
                {outputTab === 'human' && (
                  <div className="output-human">
                    {formatOutputHuman(JSON.parse(outputModal))}
                  </div>
                )}
                {outputTab === 'compare' && (() => {
                  const comparison = generateComparisonData(JSON.parse(outputModal));
                  const isMatch = comparison.left.length === comparison.right.length &&
                    comparison.left.every((evt, i) => {
                      const other = comparison.right[i];
                      return other && evt.id === other.id && Math.abs(evt.timestamp - other.timestamp) < 60000;
                    });
                  return (
                    <div>
                      <div className="compare-container">
                        <div className="compare-side">
                          <div className="compare-title">Current (Our Timeline)</div>
                          {comparison.left.map((evt, i) => (
                            <div key={i} className="compare-event">
                              <span className={`code ${evt.code}`}>{evt.code}</span>
                              {' '}<span className="time">{evt.time}</span>
                              {' '}<span className="id">{evt.id.slice(-6)}</span>
                            </div>
                          ))}
                        </div>
                        <div className="compare-side">
                          <div className="compare-title">Original + Changes (Server)</div>
                          {comparison.right.map((evt, i) => (
                            <div key={i} className="compare-event">
                              <span className={`code ${evt.code}`}>{evt.code}</span>
                              {' '}<span className="time">{evt.time}</span>
                              {' '}<span className="id">{evt.id === 'NEW' ? 'NEW' : evt.id.slice(-6)}</span>
                            </div>
                          ))}
                        </div>
                      </div>
                      {isMatch ? (
                        <div className="compare-match">âœ“ Both sides match!</div>
                      ) : (
                        <div className="compare-mismatch">âœ— Mismatch detected - check events above</div>
                      )}
                      <button
                        className="dialog-btn cancel"
                        style={{ marginTop: '12px', width: '100%' }}
                        onClick={() => {
                          const debugData = {
                            originalState: originalStatuses.map(s => ({
                              id: s.id,
                              code: s.code,
                              startMinute: s.startMinute,
                              duration: s.duration,
                              originalStartMinute: s.originalStartMinute
                            })),
                            currentState: statuses.map(s => ({
                              id: s.id,
                              code: s.code,
                              startMinute: s.startMinute,
                              duration: s.duration,
                              originalStartMinute: s.originalStartMinute
                            })),
                            output: JSON.parse(outputModal),
                            comparison: {
                              left: comparison.left,
                              right: comparison.right
                            }
                          };
                          navigator.clipboard.writeText(JSON.stringify(debugData, null, 2));
                          setNotification('Debug info copied to clipboard!');
                          setTimeout(() => setNotification(null), 2000);
                        }}
                      >
                        Copy Debug Info
                      </button>
                    </div>
                  );
                })()}
                {outputTab === 'json' && (
                  <pre>{outputModal}</pre>
                )}
                
                <div className="dialog-buttons">
                  <button 
                    className="dialog-btn submit" 
                    onClick={async () => {
                      try {
                        const rawOutput = JSON.parse(outputModal);
                        const apiPayload = formatOutputForApi(rawOutput);
                        
                        console.log('Submitting payload:', apiPayload);
                        
                        const response = await fetch('https://techsupport-be-zm8z4.ondigitalocean.app/api/webhook/automation/hos-violations', {
                          method: 'POST',
                          headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY0ZWNkYTVmYTIwODZjZTVkOGE3NWY4MCIsImlhdCI6MTc2NTI3NzYzNX0.FlTk_ndQUPG4w-5XiNd_GIV_EG4182vdlPcALiMnFQc'
                          },
                          body: JSON.stringify(apiPayload)
                        });
                        
                        if (!response.ok) {
                          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        
                        const result = await response.json();
                        console.log('Submit response:', result);
                        
                        setNotification('Successfully submitted!');
                        setTimeout(() => setNotification(null), 3000);
                        setOutputModal(null);
                      } catch (err) {
                        console.error('Submit error:', err);
                        setNotification(`Error: ${err.message}`);
                        setTimeout(() => setNotification(null), 5000);
                      }
                    }}
                  >
                    Submit
                  </button>
                  <button 
                    className="dialog-btn confirm" 
                    onClick={() => {
                      navigator.clipboard.writeText(outputModal);
                    }}
                  >
                    Copy
                  </button>
                  <button 
                    className="dialog-btn cancel" 
                    onClick={() => setOutputModal(null)}
                  >
                    Close
                  </button>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    }

    /*=====================================================
      MOVE DIALOG COMPONENT
      Modal for moving a status by a specific amount
    =====================================================*/
    function MoveDialog({ dialog, onUpdate, onConfirm, onCancel }) {
      const updateField = (field, value) => {
        onUpdate({ ...dialog, [field]: value });
      };

      const handleKeyDown = (e) => {
        if (e.key === 'Enter') onConfirm();
        if (e.key === 'Escape') onCancel();
      };

      return (
        <div className="dialog-overlay" onClick={onCancel} onKeyDown={handleKeyDown}>
          <div className="move-dialog" onClick={e => e.stopPropagation()}>
            <div className="dialog-title">Move Status</div>
            
            {/* Direction Toggle */}
            <div className="dialog-row">
              <label className="dialog-label">Direction</label>
              <div className="direction-toggle">
                <button 
                  className={`direction-btn ${dialog.direction === 'left' ? 'active' : ''}`}
                  onClick={() => updateField('direction', 'left')}
                >
                  â† Left
                </button>
                <button 
                  className={`direction-btn ${dialog.direction === 'right' ? 'active' : ''}`}
                  onClick={() => updateField('direction', 'right')}
                >
                  Right â†’
                </button>
              </div>
            </div>
            
            {/* Duration Inputs */}
            <div className="dialog-row">
              <label className="dialog-label">Duration</label>
              <div className="duration-inputs">
                <div className="duration-field">
                  <div className="duration-stepper">
                    <button 
                      className="stepper-btn" 
                      onClick={() => updateField('hours', Math.max(0, dialog.hours - 1))}
                    >
                      âˆ’
                    </button>
                    <input
                      type="number"
                      className="duration-input"
                      min="0"
                      max="99"
                      value={dialog.hours}
                      onChange={e => updateField('hours', Math.max(0, parseInt(e.target.value) || 0))}
                      autoFocus
                    />
                    <button 
                      className="stepper-btn" 
                      onClick={() => updateField('hours', dialog.hours + 1)}
                    >
                      +
                    </button>
                  </div>
                  <div className="duration-label">hours</div>
                </div>
                <span className="duration-separator">:</span>
                <div className="duration-field">
                  <div className="duration-stepper">
                    <button 
                      className="stepper-btn" 
                      onClick={() => updateField('minutes', Math.max(0, dialog.minutes - 1))}
                    >
                      âˆ’
                    </button>
                    <input
                      type="number"
                      className="duration-input"
                      min="0"
                      max="59"
                      value={dialog.minutes}
                      onChange={e => updateField('minutes', Math.min(59, Math.max(0, parseInt(e.target.value) || 0)))}
                    />
                    <button 
                      className="stepper-btn" 
                      onClick={() => updateField('minutes', Math.min(59, dialog.minutes + 1))}
                    >
                      +
                    </button>
                  </div>
                  <div className="duration-label">mins</div>
                </div>
              </div>
            </div>
            
            {/* Buttons */}
            <div className="dialog-buttons">
              <button className="dialog-btn cancel" onClick={onCancel}>
                Cancel
              </button>
              <button className="dialog-btn confirm" onClick={onConfirm}>
                Move
              </button>
            </div>
          </div>
        </div>
      );
    }

    /*=====================================================
      TIME AXIS COMPONENT
      Displays hour markers (M, 1-11, N, 1-11, M)
    =====================================================*/
    function TimeAxis() {
      return (
        <div className="time-axis">
          {Array.from({ length: 25 }, (_, i) => (
            <span 
              key={i} 
              className="time-label" 
              style={{ left: `${(i / 24) * 100}%` }}
            >
              {getHourLabel(i)}
            </span>
          ))}
        </div>
      );
    }

    /*=====================================================
      DAY ROW COMPONENT
      Single row showing one day's worth of timeline
    =====================================================*/
    function DayRow({ 
      day, 
      statuses, 
      gaps, 
      onMouseDown, 
      onGapClick, 
      onRestSegmentClick,
      onStatusClick,
      draggingId, 
      wasDragged, 
      hoveredGapId, 
      onGapHover, 
      trackRef,
      startDate
    }) {
      // Calculate the actual date for this day
      const dayDate = startDate ? new Date(startDate.getTime() + day * 24 * 60 * 60 * 1000) : null;
      const dayLabel = dayDate ? formatDateLabel(dayDate) : `Day ${day + 1}`;
      
      return (
        <div className="day-row">
          <div className="day-label">{dayLabel}</div>
          <div className="timeline-track" ref={trackRef}>
            {/* Gaps (rendered first, below statuses) */}
            {gaps.map((gap, i) => (
              <GapBlock
                key={`gap-${day}-${i}`}
                gap={gap}
                day={day}
                onClick={onGapClick}
                isHovered={hoveredGapId === gap.id}
                onHover={onGapHover}
              />
            ))}
            
            {/* Status blocks */}
            {statuses.map(status => (
              <StatusBlock
                key={`${status.id}-${day}`}
                status={status}
                day={day}
                onMouseDown={onMouseDown}
                onRestSegmentClick={onRestSegmentClick}
                onStatusClick={onStatusClick}
                isDragging={draggingId === status.id}
                wasDragged={wasDragged}
              />
            ))}
          </div>
        </div>
      );
    }

    /*=====================================================
      GAP BLOCK COMPONENT
      Empty space that can be clicked to create rest_segment
    =====================================================*/
    function GapBlock({ gap, day, onClick, isHovered, onHover }) {
      const dayStart = day * MINUTES_PER_DAY;
      const leftPercent = ((gap.visibleStart - dayStart) / MINUTES_PER_DAY) * 100;
      const widthPercent = (gap.visibleDuration / MINUTES_PER_DAY) * 100;
      const spansMultipleDays = gap.duration > gap.visibleDuration;

      // Label format: "visible (total)" for multi-day gaps
      const label = spansMultipleDays
        ? `${formatDuration(gap.visibleDuration)} (${formatDuration(gap.duration)})`
        : formatDuration(gap.visibleDuration);

      return (
        <div
          className={`gap-block ${spansMultipleDays ? 'multi-day' : ''} ${isHovered ? 'hovered' : ''}`}
          style={{ left: `${leftPercent}%`, width: `${widthPercent}%` }}
          onClick={() => onClick(gap)}
          onMouseEnter={() => onHover(gap.id)}
          onMouseLeave={() => onHover(null)}
          title={spansMultipleDays ? `Click to create ${formatDuration(gap.duration)} off-duty block` : ''}
        >
          {widthPercent > 2.5 && <span>{label}</span>}
        </div>
      );
    }

    /*=====================================================
      STATUS BLOCK COMPONENT
      Draggable rectangle representing a driver status
    =====================================================*/
    function StatusBlock({ status, day, onMouseDown, onRestSegmentClick, onStatusClick, isDragging, wasDragged }) {
      const dayStart = day * MINUTES_PER_DAY;
      const leftPercent = ((status.visibleStart - dayStart) / MINUTES_PER_DAY) * 100;
      const widthPercent = (status.visibleDuration / MINUTES_PER_DAY) * 100;

      // Adjust border radius for clipped blocks (spans multiple days)
      const style = {
        left: `${leftPercent}%`,
        width: `${widthPercent}%`,
        borderTopLeftRadius: status.clippedLeft ? 0 : 3,
        borderBottomLeftRadius: status.clippedLeft ? 0 : 3,
        borderTopRightRadius: status.clippedRight ? 0 : 3,
        borderBottomRightRadius: status.clippedRight ? 0 : 3,
      };

      const handleClick = (e) => {
        // Don't handle click if we just finished dragging or if pinned
        if (wasDragged || status.pinned) return;
        
        e.stopPropagation();
        
        if (status.code === 'rest_segment') {
          // Delete rest_segment on click
          onRestSegmentClick(status.id);
        } else {
          // Open move dialog for driving/on_duty
          onStatusClick(status.id);
        }
      };

      // Build class names
      const classNames = [
        'status-block',
        status.code,
        isDragging ? 'dragging' : '',
        status.pinned ? 'pinned' : ''
      ].filter(Boolean).join(' ');

      // Build tooltip - always show ID first
      let tooltip = `ID: ${status.id}\n`;
      tooltip += `Code: ${status.code}\n`;
      tooltip += `Duration: ${formatDuration(status.duration)}\n`;
      
      if (status.code === 'rest_segment' && status.originalEvents?.length > 0) {
        tooltip += `\nOriginal events:\n` + status.originalEvents.map((evt, i) => 
          `  ${i + 1}. ${evt.code} - ${formatDuration(evt.duration)} (id: ${evt.id})`
        ).join('\n');
        
        // Calculate delta: current duration + adjacent gaps - original duration
        const originalDuration = status.originalDuration || status.duration;
        const adjacentGaps = (status.gapBefore || 0) + (status.gapAfter || 0);
        const currentTotal = status.duration + adjacentGaps;
        const delta = currentTotal - originalDuration;
        
        tooltip += `\n\nCurrent: ${formatDuration(status.duration)}`;
        if (adjacentGaps > 0) {
          tooltip += ` + ${formatDuration(adjacentGaps)} gaps`;
        }
        tooltip += `\nOriginal: ${formatDuration(originalDuration)}`;
        tooltip += `\nAfter ID: ${status.afterId || 'none'}`;
        if (delta !== 0) {
          const sign = delta > 0 ? '+' : '';
          tooltip += `\nDelta: ${sign}${formatDuration(Math.abs(delta))}`;
        }
      } else if (status.code === 'rest_segment') {
        tooltip += '\nUser-created rest segment';
      } else if (status.afterId) {
        tooltip += `\nAfter ID: ${status.afterId}`;
      }

      return (
        <div
          className={classNames}
          style={style}
          onMouseDown={e => !status.pinned && onMouseDown(e, status.id, day)}
          onClick={handleClick}
          title={tooltip}
        >
          {widthPercent > 2.5 && formatDuration(status.duration)}
        </div>
      );
    }

    /*=====================================================
      MOUNT APP
    =====================================================*/
    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>

